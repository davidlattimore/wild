diff --git a/libwild/src/layout_rules.rs b/libwild/src/layout_rules.rs
index e37d17d..f4ffcd4 100644
--- a/libwild/src/layout_rules.rs
+++ b/libwild/src/layout_rules.rs
@@ -154,6 +154,7 @@ impl<'data> LayoutRulesBuilder<'data> {
                                             output_sections.add_secondary_section(
                                                 primary_section_id,
                                                 replace(&mut extra_min_alignment, alignment::MIN),
+                                                None,
                                             )
                                         };
 
@@ -288,10 +289,11 @@ impl<'data> SectionRule<'data> {
         name: &'data [u8],
         section_id: OutputSectionId,
     ) -> SectionRule<'data> {
-        Self::prefix(
+        SectionRule {
             name,
-            SectionRuleOutcome::Section(SectionOutputInfo::keep(section_id)),
-        )
+            is_prefix: true,
+            outcome: SectionRuleOutcome::Section(SectionOutputInfo::keep(section_id)),
+        }
     }
 
     const fn exact(name: &'data [u8], outcome: SectionRuleOutcome) -> SectionRule<'data> {
diff --git a/libwild/src/output_section_id.rs b/libwild/src/output_section_id.rs
index 7f30b28..e0e0123 100644
--- a/libwild/src/output_section_id.rs
+++ b/libwild/src/output_section_id.rs
@@ -71,6 +71,13 @@ pub(crate) struct CustomSectionDetails<'data> {
     pub(crate) alignment: Alignment,
 }
 
+#[derive(Clone, Copy, Debug, PartialEq, Eq)]
+pub(crate) struct InitFiniSectionDetail {
+    pub(crate) index: u32,
+    pub(crate) primary: OutputSectionId,
+    pub(crate) priority: u16,
+}
+
 // Single-part sections that we generate ourselves rather than copying directly from input objects.
 pub(crate) const FILE_HEADER: OutputSectionId = part_id::FILE_HEADER.output_section_id();
 pub(crate) const PROGRAM_HEADERS: OutputSectionId = part_id::PROGRAM_HEADERS.output_section_id();
@@ -136,6 +143,8 @@ pub(crate) struct OutputSections<'data> {
     pub(crate) output_section_indexes: Vec<Option<u16>>,
 
     custom_by_name: HashMap<SectionName<'data>, OutputSectionId>,
+
+    init_fini_by_priority: HashMap<(OutputSectionId, u16), OutputSectionId>,
 }
 
 /// Encodes the order of output sections and the start and end of each program segment. This struct
@@ -179,11 +188,9 @@ impl<'scope, 'data> OutputOrderBuilder<'scope, 'data> {
 
     fn add_section(&mut self, section_id: OutputSectionId) {
         let (stop, start) = self.start_stop_segments_for_section(section_id);
-
         for segment_id in stop {
             self.events.push(OrderEvent::SegmentEnd(segment_id));
         }
-
         let section_info = self.output_sections.output_info(section_id);
         debug_assert!(
             matches!(section_info.kind, SectionKind::Primary(_)),
@@ -199,15 +206,31 @@ impl<'scope, 'data> OutputOrderBuilder<'scope, 'data> {
         {
             self.events.push(OrderEvent::SetLocation(location));
         }
-
         for segment_id in start {
             self.events.push(OrderEvent::SegmentStart(segment_id));
         }
-
         self.events.push(OrderEvent::Section(section_id));
 
-        for secondary_id in self.secondary.get(section_id) {
-            self.events.push(OrderEvent::Section(*secondary_id));
+        let secondaries: Vec<OutputSectionId> = self.secondary.get(section_id).to_vec();
+        // stable ordering: tie-break by original index
+        let mut keyed: Vec<(u16, usize, OutputSectionId)> = secondaries
+            .into_iter()
+            .enumerate()
+            .map(|(idx, sid)| {
+                // default: put non-initfini after all initfini, and keep their relative order
+                let key_pri = match self.output_sections.secondary_order(sid) {
+                    Some(crate::output_section_id::SecondaryOrder::InitFini { priority }) => {
+                        priority
+                    }
+                    None => u16::MAX,
+                };
+                (key_pri, idx, sid)
+            })
+            .collect();
+        keyed.sort_by(|a, b| a.0.cmp(&b.0).then_with(|| a.1.cmp(&b.1)));
+
+        for (_pri, _idx, sid) in keyed {
+            self.events.push(OrderEvent::Section(sid));
         }
     }
 
@@ -391,6 +414,7 @@ pub(crate) struct SectionOutputInfo<'data> {
     pub(crate) min_alignment: Alignment,
     pub(crate) entsize: u64,
     pub(crate) location: Option<linker_script::Location>,
+    pub(crate) secondary_order: Option<SecondaryOrder>,
 }
 
 pub(crate) struct BuiltInSectionDetails {
@@ -884,6 +908,11 @@ impl Debug for SectionName<'_> {
     }
 }
 
+#[derive(Debug, Clone, Copy)]
+pub(crate) enum SecondaryOrder {
+    InitFini { priority: u16 },
+}
+
 impl CustomSectionIds {
     fn build_output_order_and_program_segments(
         &self,
@@ -948,6 +977,9 @@ impl CustomSectionIds {
 }
 
 impl<'data> OutputSections<'data> {
+    pub(crate) fn secondary_order(&self, id: OutputSectionId) -> Option<SecondaryOrder> {
+        self.section_infos.get(id).secondary_order
+    }
     pub(crate) fn add_sections(
         &mut self,
         custom_sections: &[CustomSectionDetails<'data>],
@@ -985,6 +1017,7 @@ impl<'data> OutputSections<'data> {
                 min_alignment,
                 entsize: 0,
                 location,
+                secondary_order: None,
             })
         })
     }
@@ -993,14 +1026,19 @@ impl<'data> OutputSections<'data> {
         &mut self,
         primary_id: OutputSectionId,
         min_alignment: Alignment,
+        secondary_order: Option<SecondaryOrder>,
     ) -> OutputSectionId {
+        let primary_entsize = self.section_infos.get(primary_id).entsize;
+        let section_flag = self.section_infos.get(primary_id).section_flags;
+        let ty = self.section_infos.get(primary_id).ty;
         self.section_infos.add_new(SectionOutputInfo {
             kind: SectionKind::Secondary(primary_id),
-            section_flags: SectionFlags::empty(),
-            ty: SectionType::from_u32(0),
+            section_flags: section_flag,
+            ty,
             min_alignment,
-            entsize: 0,
+            entsize: primary_entsize,
             location: None,
+            secondary_order,
         })
     }
 
@@ -1014,6 +1052,7 @@ impl<'data> OutputSections<'data> {
                 min_alignment: d.min_alignment,
                 entsize: d.element_size,
                 location: None,
+                secondary_order: None,
             })
             .collect();
 
@@ -1022,7 +1061,35 @@ impl<'data> OutputSections<'data> {
             base_address,
             custom_by_name: HashMap::new(),
             output_section_indexes: Default::default(),
+            init_fini_by_priority: HashMap::new(),
+        }
+    }
+
+    pub(crate) fn bump_min_alignment(&mut self, sid: OutputSectionId, a: Alignment) {
+        let info = self.section_infos.get_mut(sid);
+        info.min_alignment = core::cmp::max(info.min_alignment, a);
+    }
+
+    pub(crate) fn get_or_create_init_fini_secondary(
+        &mut self,
+        primary: OutputSectionId,
+        priority: u16,
+        min_alignment: Alignment,
+    ) -> OutputSectionId {
+        let key = (primary, priority);
+        if let Some(&sid) = self.init_fini_by_priority.get(&key) {
+            self.bump_min_alignment(sid, min_alignment);
+            return sid;
         }
+
+        let sid = self.add_secondary_section(
+            primary,
+            min_alignment,
+            Some(SecondaryOrder::InitFini { priority }),
+        );
+
+        self.init_fini_by_priority.insert(key, sid);
+        sid
     }
 
     pub(crate) fn output_order(&self) -> (OutputOrder, ProgramSegments) {
diff --git a/libwild/src/resolution.rs b/libwild/src/resolution.rs
index 50aa882..a151047 100644
--- a/libwild/src/resolution.rs
+++ b/libwild/src/resolution.rs
@@ -22,6 +22,7 @@ use crate::input_data::PRELUDE_FILE_ID;
 use crate::layout_rules::SectionRuleOutcome;
 use crate::layout_rules::SectionRules;
 use crate::output_section_id::CustomSectionDetails;
+use crate::output_section_id::InitFiniSectionDetail;
 use crate::output_section_id::OutputSections;
 use crate::output_section_id::SectionName;
 use crate::parsing::InternalSymDefInfo;
@@ -564,6 +565,8 @@ pub(crate) struct ResolvedObject<'data> {
 
     /// Details about each custom section that is defined in this object.
     custom_sections: Vec<CustomSectionDetails<'data>>,
+
+    init_fini_sections: Vec<InitFiniSectionDetail>,
 }
 
 #[derive(Debug)]
@@ -598,11 +601,38 @@ fn assign_section_ids<'data>(
         for file in &mut group.files {
             if let ResolvedFile::Object(s) = file {
                 output_sections.add_sections(&s.custom_sections, s.sections.as_mut_slice(), args);
+                apply_init_fini_secondaries(
+                    &s.init_fini_sections,
+                    s.sections.as_mut_slice(),
+                    output_sections,
+                );
             }
         }
     }
 }
 
+fn parse_priority_suffix(name: &[u8]) -> Option<u16> {
+    let idx = name.iter().rposition(|&b| b == b'.')?;
+    let suffix = name.get(idx + 1..)?;
+    if suffix.is_empty() || !suffix.iter().all(|b| b.is_ascii_digit()) {
+        return None;
+    }
+    let value = core::str::from_utf8(suffix).ok()?.parse::<u32>().ok()?;
+    Some(u16::try_from(value).unwrap_or(u16::MAX))
+}
+
+fn init_fini_priority(name: &[u8]) -> Option<u16> {
+    if name == secnames::INIT_ARRAY_SECTION_NAME || name == secnames::FINI_ARRAY_SECTION_NAME {
+        return Some(u16::MAX);
+    }
+
+    if name.starts_with(b".init_array.") || name.starts_with(b".fini_array.") {
+        return parse_priority_suffix(name);
+    }
+
+    None
+}
+
 struct Outputs<'data> {
     /// Where we put objects once we've loaded them.
     loaded: ArrayQueue<ResolvedFile<'data>>,
@@ -866,6 +896,27 @@ impl<'data> ResolvedCommon<'data> {
     }
 }
 
+fn apply_init_fini_secondaries<'data>(
+    details: &[InitFiniSectionDetail],
+    sections: &mut [SectionSlot],
+    output_sections: &mut OutputSections<'data>,
+) {
+    for d in details {
+        let Some(slot) = sections.get_mut(d.index as usize) else {
+            continue;
+        };
+
+        let unloaded = match slot {
+            SectionSlot::Unloaded(u) | SectionSlot::MustLoad(u) => u,
+            _ => continue,
+        };
+
+        let alignment = unloaded.part_id.alignment();
+        let sid =
+            output_sections.get_or_create_init_fini_secondary(d.primary, d.priority, alignment);
+        unloaded.part_id = sid.part_id_with_alignment(alignment);
+    }
+}
 impl<'data> ResolvedObject<'data> {
     fn new(common: ResolvedCommon<'data>) -> Self {
         Self {
@@ -875,6 +926,7 @@ impl<'data> ResolvedObject<'data> {
             relocations: Default::default(),
             string_merge_extras: Default::default(),
             custom_sections: Default::default(),
+            init_fini_sections: Default::default(),
         }
     }
 }
@@ -902,9 +954,6 @@ fn resolve_sections_for_object<'data>(
     loaded_metrics: &LoadedMetrics,
     rules: &SectionRules,
 ) -> Result<Vec<SectionSlot>> {
-    // Note, we build up the collection with push rather than collect because at the time of
-    // writing, object's `SectionTable::enumerate` isn't an exact-size iterator, so using collect
-    // would result in resizing.
     let mut sections = Vec::with_capacity(obj.common.object.sections.len());
     for (input_section_index, input_section) in obj.common.object.sections.enumerate() {
         sections.push(resolve_section(
@@ -961,6 +1010,14 @@ fn resolve_section<'data>(
             must_load |= output_info.must_keep;
 
             unloaded_section = UnloadedSection::new(part_id);
+
+            if let Some(priority) = init_fini_priority(section_name) {
+                obj.init_fini_sections.push(InitFiniSectionDetail {
+                    index: input_section_index.0 as u32,
+                    primary: output_info.section_id,
+                    priority,
+                });
+            }
         }
         SectionRuleOutcome::Discard => return Ok(SectionSlot::Discard),
         SectionRuleOutcome::EhFrame => {
diff --git a/linker-diff/src/lib.rs b/linker-diff/src/lib.rs
index b08bad4..d97c9cc 100644
--- a/linker-diff/src/lib.rs
+++ b/linker-diff/src/lib.rs
@@ -189,9 +189,6 @@ impl Config {
                 // DT_FLAGS.BIND_NOW
                 ".dynamic.DT_BIND_NOW",
                 ".dynamic.DT_FLAGS.BIND_NOW",
-                // TODO: Implement proper ordering of .init .ctors etc
-                "init_array",
-                "fini_array",
                 // When GNU ld encounters a GOT-forming reference to an ifunc, it generates a
                 // canonical PLT entry and points the GOT at that. This means that it ends up with
                 // GOT->PLT->GOT. We don't as yet support doing this.
diff --git a/wild/tests/integration_tests.rs b/wild/tests/integration_tests.rs
index 34ee0c9..e5734b6 100644
--- a/wild/tests/integration_tests.rs
+++ b/wild/tests/integration_tests.rs
@@ -3122,6 +3122,7 @@ fn integration_test(
         "weak-fns-archive.c",
         "init_test.c",
         "ifunc.c",
+        "init-order.c",
         "internal-syms.c",
         "tls.c",
         "tlsdesc.c",
diff --git a/wild/tests/sources/ctors.c b/wild/tests/sources/ctors.c
index 0c1cb21..a274cd0 100644
--- a/wild/tests/sources/ctors.c
+++ b/wild/tests/sources/ctors.c
@@ -1,6 +1,8 @@
 //#LinkerDriver:gcc
 //#DiffIgnore:section.data
 //#DiffIgnore:section.rodata
+//#DiffIgnore:init_array
+//#DiffIgnore:fini_array
 
 static int ctors_init_val = 0;
 
diff --git a/wild/tests/sources/init-order-2.c b/wild/tests/sources/init-order-2.c
new file mode 100644
index 0000000..541874f
--- /dev/null
+++ b/wild/tests/sources/init-order-2.c
@@ -0,0 +1,17 @@
+// Constructors
+
+__attribute__((constructor(2000))) void init_2000c() {}
+__attribute__((constructor(2000))) void init_2000d() {}
+__attribute__((constructor(1000))) void init_1000c() {}
+__attribute__((constructor(1000))) void init_1000d() {}
+__attribute__((constructor)) void init_c() {}
+__attribute__((constructor)) void init_d() {}
+
+// Destructors
+
+__attribute__((destructor(2000))) void fini_2000c() {}
+__attribute__((destructor(2000))) void fini_2000d() {}
+__attribute__((destructor(1000))) void fini_1000c() {}
+__attribute__((destructor(1000))) void fini_1000d() {}
+__attribute__((destructor)) void fini_c() {}
+__attribute__((destructor)) void fini_d() {}
\ No newline at end of file
diff --git a/wild/tests/sources/init-order.c b/wild/tests/sources/init-order.c
new file mode 100644
index 0000000..ccc243a
--- /dev/null
+++ b/wild/tests/sources/init-order.c
@@ -0,0 +1,35 @@
+//#Object:runtime.c
+//#Object:init-order-2.c
+//#DiffIgnore:section.data
+//#DiffIgnore:section.rodata
+
+#include "runtime.h"
+
+static int ctors_init_val = 0;
+
+// Constructors
+
+__attribute__((constructor)) void init_a() {}
+__attribute__((constructor)) void init_b() {}
+__attribute__((constructor(1000))) void init_1000a() {}
+__attribute__((constructor(1000))) void init_1000b() {}
+__attribute__((constructor(2000))) void init_2000a() {}
+__attribute__((constructor(2000))) void init_2000b() {}
+__attribute__((constructor(65535))) void init_65535a() {}
+
+// Destructors
+
+__attribute__((destructor)) void fini_a() {}
+__attribute__((destructor)) void fini_b() {}
+__attribute__((destructor(1000))) void fini_1000a() {}
+__attribute__((destructor(1000))) void fini_1000b() {}
+__attribute__((destructor(2000))) void fini_2000a() {}
+__attribute__((destructor(2000))) void fini_2000b() {}
+__attribute__((destructor(65535))) void fini_65535a() {}
+
+void _start(void) {
+  runtime_init();
+  // This test currently just relies on linker-diff to verify the init_array and
+  // fini_array orderings.
+  exit_syscall(42);
+}
\ No newline at end of file
